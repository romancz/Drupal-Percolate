<?php

define('PI_IMPORT_TYPE_USER', 1);
define('PI_IMPORT_TYPE_GROUP', 2);
define('PI_IMPORT_SETTINGS', 'pi_import_defaults');
define('PI_IMPORT_DEFAULT_FREQUENCY', 3600);

include_once('pi_import.admin.inc');

/**
 * Implements hook_menu().
 */
function pi_import_menu() {
  $items['admin/content/percolate'] = array(
    'title' => 'Percolate Import',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pi_import_form'),
    'access arguments' => array('percolate import'),
  );
  
  $items['admin/config/content/percolate/import'] = array(
    'title' => 'Import settings',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pi_import_settings_form'),
    'access arguments' => array('configure percolate import'),
    'weight' => 10,
  );
  
  return $items;
}


/**
 * Implements hook_permission().
 */
function pi_import_permission() {
  return array(
    'percolate import' => array(
      'title' => t('Import content from Percolate'),
      'description' => t('Gives user access to the import content from percolate form.'),
    ),
    'configure percolate import' => array(
      'title' => t('Configure percolate import settings'),
      'description' => t('Allows user to configure percolate import settings at admin/config/content/percolate/import'),
    ),
  );
}


/**
 * Import posts based on the settings at the import form.
 *
 * @param boolean $use_batch - Whether or not to use batch processing for
 *    posts. Should be used when the user initiates the import.
 */
function pi_import_form_import($use_batch = TRUE) {
  $settings = pi_import_settings();
  $api = pi_build_api();

  if ($settings['content_type'] && $settings['import_id'] && $api) {
    $posts = pi_import_form_get_posts($api, $settings);
    if (empty($posts)) {
      return;
    }

    if ($use_batch) {
      $ops = array();
      foreach ($posts['data'] as $post) {
        $ops[] = array('pi_import_import_post', array($post, $settings));
      }
      
      $batch = array(
        'operations' => $ops,
        'finished' => 'pi_import_batch_finished',
        'title' => t('Percolate Import'),
        'init_message' => t('Retrieving posts from Percolate.'),
        'progress_message' => t('Imported @current out of @total posts.'),
      );
      batch_set($batch);
    }
    else {
      foreach ($posts['data'] as $post) {
        pi_import_import_post($post, $settings);
      }
    }
  }
}


/**
 * Get list of posts based on the import form's settings.
 */
function pi_import_form_get_posts($api, $settings) {
  try {
    $users = array();
    if ($settings['import_type'] == PI_IMPORT_TYPE_GROUP) {
      $users = $api->getGroupUsers($settings['import_id']);
    }
    else {
      $users[] = $api->getUser($settings['import_id']);
    }
    $posts = array();
    foreach ($users as $user) {
      $posts = array_merge($posts, $api->getUserPosts($user['id'], array(
        'limit' => $settings['import_count'],
      )));
    }
    return $posts;
  }
  catch (PercolateException $e) {
    drupal_set_message(t('@type with an ID of %id does not exist.', array(
      '@type' => $settings['import_type'] == PI_IMPORT_TYPE_USER ? 'User' : 'Group',
      '%id' => $settings['import_id'],
    )), 'error');
    return array();
  }
}


/**
 * Batch operation. Imports a percolate post using the mapping from the
 * import form. Returns saved node.
 */
function pi_import_import_post($post, $settings, &$context = array()) {
  // Initialize.
  if (empty($context['results'])) {
    $context['results'] = array(
      'imported' => 0,
      'drafts' => 0,
      'duplicates' => 0,
      'total' => 0,
    );
  }
  $context['results']['total']++;

  // Don't import draft posts.
  if (empty($post['published_to']) || !$post['published_to']['public']) {
    $context['results']['drafts']++;
    return FALSE;
  }
  
  // Don't import duplicates, unless deleted and configured that way.
  if ($post_mapping = pi_get_mappings_by_post($post['id'], 'node')) {
    $post_mapping = array_pop($post_mapping);
    if (!$settings['reimport_deleted'] || !$post_mapping->deleted) {
      $context['results']['duplicates']++;
      return FALSE;
    }
  }

  $mappings = $settings['field_mappings'][$settings['content_type']];
  $node_fields = pi_get_content_type_fields($settings['content_type']);
  
  // Alter post for assignment.
  $post['link_url'] = $post['link']['url'];
  $post['link_title'] = $post['link']['title'];
  $post['link_description'] = $post['link']['description'];
  
  // Initialize new node.
  $node = new stdClass();
  $node->title = $post['title'];
  $node->type = $settings['content_type'];
  node_object_prepare($node);
  $node->language = LANGUAGE_NONE;
  $node->status = $settings['publish'] ? 1 : 0;
  $node->created = $settings['match_publish_date'] ? strtotime($post['created_at']) : time();
  
  // Determine whether or not we have the post author mapped to a drupal user.
  $uid = pi_get_user_from_percolate_user_id($post['user_id']);
  $node->uid = $uid ? $uid : $settings['default_author'];
  
  
  foreach ($mappings as $node_field => $post_field) {
    if ($post_field) {
      $field_info = field_info_field($node_fields[$node_field]['field_name']);
      // Link fields are split out.
      if ($field_info['type'] == 'link_field') {
        $type = strstr($node_field, ':url') ? 'url' : 'title';
        $node->{$field_info['field_name']}[LANGUAGE_NONE][0][$type] = $post[$post_field];
      }
      else {
        switch ($post_field) {
          case 'tags':
            $tags = pi_import_tags($post, $field_info['settings']['allowed_values'][0]['vocabulary']);
            if ($tags) {
              $node->{$field_info['field_name']}[LANGUAGE_NONE] = $tags;
            }
            break;
            
          case 'media':
            $media = pi_import_media($post);
            if ($media) {
              $node->{$field_info['field_name']}[LANGUAGE_NONE][0] = get_object_vars($media);
            }
            break;
            
          default:
            $node->{$field_info['field_name']}[LANGUAGE_NONE][0]['value'] = ($post[$post_field]);
            break;
        }
      }
    }
  }
  
  node_save($node);
  pi_map_entity_to_post('node', $node->type, $node->nid, $post['id'], $post['user_id']);
  $context['results']['imported']++;
}


/**
 * Imports a media file from percolate. Returns file object.
 */
function pi_import_media($post) {
  if (empty($post['media'])) {
    return FALSE;
  }

  $url = $post['media']['images']['original']['url'];
  $id = $post['media']['id'];
  
  $media_data = drupal_http_request($url);
  if (isset($media_data->error)) {
    $msg = t('Failed to retrieve media at !url during Percolate import of post !id.', array(
      '!url' => $url,
      '!id' => $post['id'],
    ));
    watchdog('Percolate Integration Import', $msg);
    drupal_set_message($msg, 'error');
    return FALSE;
  }
  
  // $post['media']['format'] is not reliable, get it straight from the url.
  $format = array_pop(explode('.', $post['media']['src']));
  $dir = 'public://percolate_import';
  file_prepare_directory($dir, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS);
  $file = file_save_data($media_data->data, $dir . '/' . $id . '.' . $format, FILE_EXISTS_REPLACE);
  return $file;
}


/**
 * Imports tags, returns fieldable values.
 */
function pi_import_tags($post, $vocab, $create = TRUE) {
  $tags = array();
  $vocab = taxonomy_vocabulary_machine_name_load($vocab);
  foreach ($post['tags'] as $tag) {
    // Attempt to load existing term.
    $term = taxonomy_get_term_by_name($tag['tag'], $vocab->machine_name);
    // Otherwise create a new one.
    if (!$term && $create) {
      $term = new stdClass();
      $term->vid = $vocab->vid;
      $term->name = $tag['tag'];
      $term = taxonomy_term_save($term);
    }
    
    if ($term = array_pop($term)) {
      $tags[]['tid'] = $term->tid;
    }
  }
  
  return $tags;
}


/**
 * Batch complete function. Let them know the results of the import.
 */
function pi_import_batch_finished($success, $results, $ops) {
  $message = t('!total posts checked. !imported posts were imported, !drafts posts were still in the draft state, and !duplicates posts have already been imported.', array(
    '!total' => $results['total'],
    '!imported' => $results['imported'],
    '!drafts' => $results['drafts'],
    '!duplicates' => $results['duplicates'],
  ));
  drupal_set_message($message);
  watchdog('Percolate Integration Import', $message);
}



/**
 * Implements hook_cron().
 */
function pi_import_cron() {
  if (variable_get('pi_import_automatic_import', FALSE)) {
    $import_frequency = variable_get('pi_import_threshold', 0);
    $last_import = variable_get('pi_import_last_import', 0);
    if (time() > $import_frequency + $last_import) {
      pi_import_form_import(FALSE);
      variable_set('pi_import_last_import', time());
    }
  }
}
